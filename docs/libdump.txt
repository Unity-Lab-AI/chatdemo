0001: // Compatibility wrapper for browser + Node usage without requiring tokens.0002: // Exposes: PolliClient (lite), textModels, chat, image, DEFAULT_REFERRER0003: 0004: export const DEFAULT_REFERRER = 'https://www.unityailab.com';0005: 0006: function getFetch(fn) {0007:   if (typeof fn === 'function') return fn;0008:   if (typeof fetch === 'function') return fetch.bind(globalThis);0009:   throw new Error('fetch is not available; provide opts.fetch');0010: }0011: 0012: function normalizeModels(raw) {0013:   if (raw && typeof raw === 'object' && !Array.isArray(raw) && Array.isArray(raw.models)) raw = raw.models;0014:   if (!Array.isArray(raw)) return [];0015:   return raw.map(item => (typeof item === 'string' ? { name: item } : { ...item }));0016: }0017: 0018: export class PolliClient {0019:   constructor(opts = {}) {0020:     this.fetch = getFetch(opts.fetch);0021:     this.textPromptBase = opts.textPromptBase || 'https://text.pollinations.ai';0022:     this.imagePromptBase = opts.imagePromptBase || 'https://image.pollinations.ai/prompt';0023:     this.timeoutMs = opts.timeoutMs || 60_000;0024:   }0025: 0026:   async listModels(kind = 'text') {0027:     const url = kind === 'image' ? 'https://image.pollinations.ai/models' : 'https://text.pollinations.ai/models';0028:     const r = await this.fetch(url, { method: 'GET' });0029:     if (!r.ok) throw new Error(`HTTP ${r.status}`);0030:     const json = await r.json();0031:     return normalizeModels(json);0032:   }0033: 0034:   async generate_text(prompt, { model = 'openai', system = null, referrer = null, asJson = false, timeoutMs = this.timeoutMs } = {}) {0035:     const u = new URL(`${this.textPromptBase}/${encodeURIComponent(String(prompt))}`);0036:     u.searchParams.set('model', model);0037:     if (system) u.searchParams.set('system', system);0038:     if (referrer) u.searchParams.set('referrer', referrer);0039:     const controller = new AbortController();0040:     const t = setTimeout(() => controller.abort(), timeoutMs);0041:     try {0042:       const r = await this.fetch(u, { method: 'GET', signal: controller.signal });0043:       if (!r.ok) throw new Error(`HTTP ${r.status}`);0044:       if (asJson) {0045:         const text = await r.text();0046:         try { return JSON.parse(text); } catch { return text; }0047:       }0048:       return await r.text();0049:     } finally { clearTimeout(t); }0050:   }0051: 0052:   async chat_completion(messages, { model = 'openai', referrer = null, asJson = true, timeoutMs = this.timeoutMs, ...rest } = {}) {0053:     const url = `${this.textPromptBase}/${model}`;0054:     const payload = { model, messages, ...(referrer ? { referrer } : {}), ...rest };0055:     const controller = new AbortController();0056:     const t = setTimeout(() => controller.abort(), timeoutMs);0057:     try {0058:       const r = await this.fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal: controller.signal });0059:       if (!r.ok) throw new Error(`HTTP ${r.status}`);0060:       const data = await r.json();0061:       return asJson ? data : (data?.choices?.[0]?.message?.content ?? '');0062:     } finally { clearTimeout(t); }0063:   }0064: 0065:   async chat_completion_tools(messages, { tools, tool_choice = 'auto', model = 'openai', referrer = null, asJson = true, timeoutMs = this.timeoutMs, ...rest } = {}) {0066:     const url = `${this.textPromptBase}/${model}`;0067:     const payload = { model, messages, tools, tool_choice, ...(referrer ? { referrer } : {}), ...rest };0068:     const controller = new AbortController();0069:     const t = setTimeout(() => controller.abort(), timeoutMs);0070:     try {0071:       const r = await this.fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal: controller.signal });0072:       if (!r.ok) throw new Error(`HTTP ${r.status}`);0073:       const data = await r.json();0074:       return asJson ? data : (data?.choices?.[0]?.message?.content ?? '');0075:     } finally { clearTimeout(t); }0076:   }0077: 0078:   async generate_image(prompt, { width = 1024, height = 1024, model = 'flux', nologo = true, seed = null, referrer = null, timeoutMs = 120_000 } = {}) {0079:     const params = new URLSearchParams({ width: String(width), height: String(height), model: String(model) });0080:     if (nologo) params.set('nologo', 'true');0081:     if (seed != null) params.set('seed', String(seed));0082:     if (referrer) params.set('referrer', referrer);0083:     const url = `${this.imagePromptBase}/${encodeURIComponent(String(prompt))}?${params}`;0084:     const controller = new AbortController();0085:     const t = setTimeout(() => controller.abort(), timeoutMs);0086:     try {0087:       const r = await this.fetch(url, { method: 'GET', signal: controller.signal });0088:       if (!r.ok) throw new Error(`HTTP ${r.status}`);0089:       return await r.arrayBuffer();0090:     } finally { clearTimeout(t); }0091:   }0092: }0093: 0094: function resolveReferrer() {0095:   try {0096:     // Prefer meta override0097:     if (typeof document !== 'undefined' && document?.querySelector) {0098:       const names = ['polli-referrer', 'pollinations-referrer'];0099:       for (const name of names) {0100:         const meta = document.querySelector(`meta[name="${name}"]`);0101:         if (meta) {0102:           const v = meta.getAttribute('content');0103:           if (typeof v === 'string' && v.trim()) return v.trim();0104:         }0105:       }0106:     }0107:     // Window globals0108:     if (typeof window !== 'undefined') {0109:       const winVals = [window.POLLI_REFERRER, window.__POLLI_REFERRER__];0110:       for (const v of winVals) {0111:         if (typeof v === 'string' && v.trim()) return v.trim();0112:       }0113:     }0114:     // Env (Vite or Node)0115:     const env = (typeof import !== 'undefined' && typeof import.meta !== 'undefined' && import.meta.env) ? import.meta.env : undefined;0116:     const penv = (typeof process !== 'undefined' && process?.env) ? process.env : undefined;0117:     const envVals = [env?.VITE_POLLI_REFERRER, env?.POLLI_REFERRER, penv?.VITE_POLLI_REFERRER, penv?.POLLI_REFERRER];0118:     for (const v of envVals) {0119:       if (typeof v === 'string' && v.trim()) return v.trim();0120:     }0121:     // Page origin0122:     if (typeof window !== 'undefined' && window.location?.origin) return window.location.origin;0123:     if (typeof document !== 'undefined' && document.location?.origin) return document.location.origin;0124:   } catch {}0125:   return DEFAULT_REFERRER;0126: }0127: 0128: export async function textModels(client) {0129:   const c = client instanceof PolliClient ? client : new PolliClient();0130:   return c.listModels('text');0131: }0132: 0133: export async function chat(payload, client) {0134:   const c = client instanceof PolliClient ? client : new PolliClient();0135:   const referrer = resolveReferrer();0136:   const { endpoint = 'openai', model: selectedModel = 'openai', messages = [], tools = null, tool_choice = 'auto', ...extra } = payload || {};0137: 0138:   // Build OpenAI-compatible route with model/seed/referer as query params0139:   const search = new URLSearchParams();0140:   search.set('model', String(selectedModel));0141:   if (extra.seed != null) search.set('seed', String(extra.seed));0142:   if (referrer) search.set('referer', referrer);0143:   if (extra.token) search.set('token', String(extra.token));0144:   // Choose provider route: seed-family models should hit /seed, else /openai0145:   const isSeedFamily =0146:     String(endpoint).toLowerCase() === 'seed' || /unity|flux|kontext|chatdolphin|hunyuan|kling|blackforest/i.test(String(selectedModel));0147:   const route = isSeedFamily ? 'seed' : 'openai';0148:   const url = `${c.textPromptBase}/${route}?${search.toString()}`;0149:   const body = { model: selectedModel, messages, ...(referrer ? { referrer } : {}), ...(Array.isArray(tools) && tools.length ? { tools, tool_choice } : {}) };0150: 0151:   const controller = new AbortController();0152:   const t = setTimeout(() => controller.abort(), c.timeoutMs);0153:   try {0154:     try {0155:       const log = (globalThis && (globalThis.__PANEL_LOG__ ||= []));0156:       log.push({ ts: Date.now(), kind: 'chat:request', url, model: selectedModel, referer: referrer || null, meta: { tool_count: Array.isArray(tools) ? tools.length : 0, endpoint: endpoint || 'openai', route } });0157:     } catch {}0158:     const r = await c.fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body), signal: controller.signal });0159:     if (!r.ok) throw new Error(`HTTP ${r.status}`);0160:     const data = await r.json();0161:     // Augment metadata to help UI match requested vs served model0162:     try {0163:       if (data && typeof data === 'object') {0164:         const meta = data.metadata && typeof data.metadata === 'object' ? data.metadata : (data.metadata = {});0165:         meta.requested_model = selectedModel;0166:         meta.requestedModel = selectedModel;0167:         meta.endpoint = endpoint || 'openai';0168:         if (!Array.isArray(data.modelAliases)) data.modelAliases = [];0169:         if (!data.modelAliases.includes(selectedModel)) data.modelAliases.push(selectedModel);0170:       }0171:     } catch {}0172:     try {0173:       const log = (globalThis && globalThis.__PANEL_LOG__);0174:       if (log) log.push({ ts: Date.now(), kind: 'chat:response', url, model: data?.model || null, ok: true });0175:     } catch {}0176:     return data;0177:   } finally {0178:     try {0179:       const log = (globalThis && globalThis.__PANEL_LOG__);0180:       if (log) log.splice(0, Math.max(0, log.length - 100));0181:     } catch {}0182:     clearTimeout(t);0183:   }0184: }0185: 0186: export async function image(prompt, options, client) {0187:   const c = client instanceof PolliClient ? client : new PolliClient();0188:   const referrer = resolveReferrer();0189:   const { width = 1024, height = 1024, model = 'flux', nologo = true, seed = null } = options || {};0190:   const arr = await c.generate_image(String(prompt || '').trim(), { width, height, model, nologo, seed: seed == null ? undefined : seed, referrer });0191:   const contentType = 'image/jpeg';0192:   function toBase64FromArrayBuffer(buf) {0193:     if (typeof Buffer !== 'undefined') return Buffer.from(buf).toString('base64');0194:     let binary = '';0195:     const bytes = new Uint8Array(buf);0196:     const len = bytes.byteLength;0197:     for (let i = 0; i < len; i += 1) binary += String.fromCharCode(bytes[i]);0198:     if (typeof btoa === 'function') return btoa(binary);0199:     return '';0200:   }0201:   return { toDataUrl() { return `data:${contentType};base64,${toBase64FromArrayBuffer(arr)}`; } };0202: }0203: 0204: 0205: 